{"ast":null,"code":"function e(e, t) {\n  for (let r in e) t(e[r], r);\n}\nfunction t(e, t) {\n  e.forEach(t);\n}\nfunction r(e, t) {\n  if (!e) throw Error(t);\n}\nfunction n(e, t) {\n  ce = {\n    parent: ce,\n    value: e,\n    template: G(e, 'template') || pe(),\n    sidRoot: G(e, 'sidRoot') || ce && ce.sidRoot\n  };\n  try {\n    return t();\n  } finally {\n    ce = H(ce);\n  }\n}\nfunction a() {\n  let {\n    node: e = [],\n    from: r,\n    source: n,\n    parent: a = r || n,\n    to: i,\n    target: o,\n    child: l = i || o,\n    scope: s = {},\n    meta: f = {},\n    family: u = {\n      type: 'regular'\n    },\n    regional: d\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let c = ye(a),\n    p = ye(u.links),\n    m = ye(u.owners),\n    g = [];\n  t(e, e => e && oe(g, e));\n  let h = {\n    id: de(),\n    seq: g,\n    next: ye(l),\n    meta: f,\n    scope: s,\n    family: {\n      type: u.type || \"crosslink\",\n      links: p,\n      owners: m\n    }\n  };\n  return t(p, e => oe(V(e), h)), t(m, e => oe(L(e), h)), t(c, e => oe(e.next, h)), d && ce && he(B(ce), [h]), h;\n}\nfunction i(e, r, n) {\n  let a = Ze,\n    i = null,\n    o = Ke;\n  if (e.target && (r = e.params, n = e.defer, a = 'page' in e ? e.page : a, e.stack && (i = e.stack), o = U(e) || o, e = e.target), o && Ke && o !== Ke && (Ke = null), Array.isArray(e)) for (let t = 0; t < e.length; t++) He('pure', a, _(e[t]), i, r[t], o);else He('pure', a, _(e), i, r, o);\n  if (n && !Qe) return;\n  let l,\n    s,\n    f,\n    u,\n    d,\n    c,\n    p = {\n      isRoot: Qe,\n      currentPage: Ze,\n      scope: Ke,\n      isWatch: Xe,\n      isPure: Ye\n    };\n  Qe = 0;\n  e: for (; u = We();) {\n    let {\n      idx: e,\n      stack: r,\n      type: n\n    } = u;\n    f = r.node, Ze = d = r.page, Ke = U(r), d ? c = d.reg : Ke && (c = Ke.reg);\n    let a = !!d,\n      i = !!Ke,\n      o = {\n        fail: 0,\n        scope: f.scope\n      };\n    l = s = 0;\n    for (let t = e; t < f.seq.length && !l; t++) {\n      let u = f.seq[t];\n      if (u.order) {\n        let {\n            priority: a,\n            barrierID: i\n          } = u.order,\n          o = i ? d ? `${d.fullID}_${i}` : i : 0;\n        if (t !== e || n !== a) {\n          i ? Je.has(o) || (Je.add(o), Ue(t, r, a, i)) : Ue(t, r, a);\n          continue e;\n        }\n        i && Je.delete(o);\n      }\n      switch (u.type) {\n        case 'mov':\n          {\n            let e,\n              t = u.data;\n            switch (t.from) {\n              case P:\n                e = B(r);\n                break;\n              case \"a\":\n              case 'b':\n                e = r[t.from];\n                break;\n              case \"value\":\n                e = t.store;\n                break;\n              case \"store\":\n                if (c && !c[t.store.id]) if (a) {\n                  let e = rt(d, t.store.id);\n                  r.page = d = e, e ? c = e.reg : i ? (ot(Ke, t.store, 0, 1, t.softRead), c = Ke.reg) : c = void 0;\n                } else i && ot(Ke, t.store, 0, 1, t.softRead);\n                e = Pe(c && c[t.store.id] || t.store);\n            }\n            switch (t.to) {\n              case P:\n                r.value = e;\n                break;\n              case \"a\":\n              case 'b':\n                r[t.to] = e;\n                break;\n              case \"store\":\n                nt(d, Ke, f, t.target).current = e;\n            }\n            break;\n          }\n        case 'compute':\n          let e = u.data;\n          if (e.fn) {\n            Xe = 'watch' === G(f, 'op'), Ye = e.pure;\n            let t = e.safe ? (0, e.fn)(B(r), o.scope, r) : lt(o, e.fn, r);\n            e.filter ? s = !t : r.value = t, Xe = p.isWatch, Ye = p.isPure;\n          }\n      }\n      l = o.fail || s;\n    }\n    if (!l) {\n      let e = B(r),\n        n = U(r);\n      if (t(f.next, t => {\n        He('child', d, t, r, e, n);\n      }), n) {\n        G(f, 'needFxCounter') && He('child', d, n.fxCount, r, e, n), G(f, 'storeChange') && He('child', d, n.storeChange, r, e, n), G(f, 'warnSerialize') && He('child', d, n.warnSerializeNode, r, e, n);\n        let a = n.additionalLinks[f.id];\n        a && t(a, t => {\n          He('child', d, t, r, e, n);\n        });\n      }\n    }\n  }\n  Qe = p.isRoot, Ze = p.currentPage, Ke = U(p);\n}\nfunction o(t) {\n  let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"combine\";\n  let n = r + '(',\n    a = '',\n    i = 0;\n  return e(t, e => {\n    i < 25 && (null != e && (n += a, n += Q(e) ? K(e).fullName : e.toString()), i += 1, a = ', ');\n  }), n + ')';\n}\nfunction l(e, t) {\n  e.shortName = t, Object.assign(K(e), s(t, H(e)));\n}\nfunction s(e, t) {\n  let r,\n    n,\n    a = e;\n  if (t) {\n    let a = K(t);\n    0 === e.length ? (r = a.path, n = a.fullName) : (r = a.path.concat([e]), n = 0 === a.fullName.length ? e : a.fullName + '/' + e);\n  } else r = 0 === e.length ? [] : [e], n = e;\n  return {\n    shortName: a,\n    fullName: n,\n    path: r\n  };\n}\nfunction f(e, t) {\n  let r = t ? e : e[0];\n  we(r);\n  let n = r.or,\n    a = r.and;\n  if (a) {\n    let r = t ? a : a[0];\n    if (be(r) && 'and' in r) {\n      let r = f(a, t);\n      e = r[0], n = {\n        ...n,\n        ...r[1]\n      };\n    } else e = a;\n  }\n  return [e, n];\n}\nfunction u(e) {\n  let r = pe();\n  if (r) {\n    let n = r.handlers[e];\n    for (var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      t[_key - 1] = arguments[_key];\n    }\n    if (n) return n(r, ...t);\n  }\n}\nfunction d(e, t) {\n  let r = st({\n      or: t,\n      and: 'string' == typeof e ? {\n        name: e\n      } : e\n    }),\n    n = function (e) {\n      for (var _len2 = arguments.length, t = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        t[_key2 - 1] = arguments[_key2];\n      }\n      return le(!G(n, 'derived'), 'call of derived event', 'createEvent'), le(!Ye, 'unit call from pure function', 'operators like sample'), Ze ? ((e, t, r, n) => {\n        let a = Ze,\n          i = null;\n        if (t) for (i = Ze; i && i.template !== t;) i = H(i);\n        tt(i);\n        let o = e.create(r, n);\n        return tt(a), o;\n      })(n, o, e, t) : n.create(e, t);\n    },\n    o = pe(),\n    l = Object.assign(n, {\n      graphite: a({\n        meta: bt(\"event\", n, r),\n        regional: 1\n      }),\n      create: e => (i({\n        target: n,\n        params: e,\n        scope: Ke\n      }), e),\n      watch: e => ht(n, e),\n      map: e => vt(n, R, e, [De()]),\n      filter: e => vt(n, \"filter\", e.fn ? e : e.fn, [De(Ce, 1)]),\n      filterMap: e => vt(n, 'filterMap', e, [De(), Oe(e => !ke(e), 1)]),\n      prepend(e) {\n        let t = d('* \\u2192 ' + n.shortName, {\n          parent: H(n)\n        });\n        return u('eventPrepend', _(t)), mt(t, n, [De()], 'prepend', e), yt(n, t), t;\n      }\n    });\n  return null != r && r.domain && r.domain.hooks.event(l), l;\n}\nfunction c(e, n) {\n  let o = st(n),\n    l = Re(e),\n    s = d({\n      named: 'updates',\n      derived: 1\n    });\n  u('storeBase', l);\n  let f = l.id,\n    p = {\n      subscribers: new Map(),\n      updates: s,\n      defaultState: e,\n      stateRef: l,\n      getState() {\n        let e,\n          t = l;\n        if (Ze) {\n          let t = Ze;\n          for (; t && !t.reg[f];) t = H(t);\n          t && (e = t);\n        }\n        return !e && Ke && (ot(Ke, l, 1), e = Ke), e && (t = e.reg[f]), Pe(t);\n      },\n      setState: e => i({\n        target: p,\n        params: e,\n        defer: 1,\n        scope: Ke\n      }),\n      reset: function () {\n        for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          e[_key3] = arguments[_key3];\n        }\n        return t(e, e => p.on(e, () => p.defaultState)), p;\n      },\n      on: (e, n) => (xe(e, '.on', 'first argument'), r(ve(n), 'second argument should be a function'), le(!G(p, 'derived'), '.on in derived store', 'createStore'), t(Array.isArray(e) ? e : [e], e => {\n        p.off(e), W(p).set(e, pt(kt(e, p, 'on', je, n)));\n      }), p),\n      off(e) {\n        let t = W(p).get(e);\n        return t && (t(), W(p).delete(e)), p;\n      },\n      map(e, t) {\n        let r, n;\n        be(e) && (r = e, e = e.fn), le(ke(t), 'second argument of store.map', 'updateFilter');\n        let a = p.getState();\n        pe() ? n = null : ke(a) || (n = e(a, t));\n        let i = c(n, {\n            name: `${p.shortName} \\u2192 *`,\n            derived: 1,\n            and: r\n          }),\n          o = kt(p, i, R, Me, e);\n        return _e(T(i), {\n          type: R,\n          fn: e,\n          from: l\n        }), T(i).noInit = 1, u('storeMap', l, o), i;\n      },\n      watch(e, t) {\n        if (!t || !Q(e)) {\n          let t = ht(p, e);\n          return u('storeWatch', l, e) || e(p.getState()), t;\n        }\n        return r(ve(t), 'second argument should be a function'), e.watch(e => t(p.getState(), e));\n      }\n    },\n    m = bt(\"store\", p, o),\n    g = p.defaultConfig.updateFilter;\n  p.graphite = a({\n    scope: {\n      state: l,\n      fn: g\n    },\n    node: [Oe((e, t, r) => (r.scope && !r.scope.reg[l.id] && (r.b = 1), e)), Fe(l), Oe((e, t, _ref) => {\n      let {\n        a: r,\n        b: n\n      } = _ref;\n      return !ke(e) && (e !== r || n);\n    }, 1), g && De(Me, 1), Ie({\n      from: P,\n      target: l\n    })],\n    child: s,\n    meta: m,\n    regional: 1\n  });\n  let h = G(p, 'serialize'),\n    y = G(p, 'derived'),\n    b = 'ignore' === h,\n    v = !h || b ? 0 : h,\n    k = G(p, 'sid');\n  return k && (b || J(p, 'storeChange', 1), l.sid = k, v && (l.meta = {\n    ...(null == l ? void 0 : l.meta),\n    serialize: v\n  })), k || b || y || J(p, 'warnSerialize', 1), r(y || !ke(e), \"current state can't be undefined, use null instead\"), he(p, [s]), null != o && o.domain && o.domain.hooks.store(p), y || (p.reinit = d(), p.reset(p.reinit)), p;\n}\nfunction p() {\n  for (var _len4 = arguments.length, e = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    e[_key4] = arguments[_key4];\n  }\n  let t, n, a;\n  [e, a] = f(e);\n  let i,\n    o,\n    l,\n    s = e[e.length - 1];\n  if (ve(s) ? (n = e.slice(0, -1), t = s) : n = e, 1 === n.length) {\n    let e = n[0];\n    Y(e) || (i = e, o = 1);\n  }\n  if (!o && (i = n, t)) {\n    l = 1;\n    let e = t;\n    t = t => e(...t);\n  }\n  return r(be(i), 'shape should be an object'), wt(Array.isArray(i), !l, i, a, t);\n}\nfunction m() {\n  return le(0, 'createStoreObject', 'combine'), p(...arguments);\n}\nfunction g() {\n  let e = {};\n  return e.req = new Promise((t, r) => {\n    e.rs = t, e.rj = r;\n  }), e.req.catch(() => {}), e;\n}\nfunction h(e, t) {\n  let n = st(ve(e) ? {\n      handler: e\n    } : e, t),\n    o = d(ve(e) ? {\n      handler: e\n    } : e, t),\n    l = _(o);\n  J(l, 'op', o.kind = \"effect\"), o.use = e => (r(ve(e), '.use argument should be a function'), h.scope.handler = e, o), o.use.getCurrent = () => h.scope.handler;\n  let s = o.finally = d({\n      named: 'finally',\n      derived: 1\n    }),\n    f = o.done = s.filterMap({\n      named: 'done',\n      fn(_ref2) {\n        let {\n          status: e,\n          params: t,\n          result: r\n        } = _ref2;\n        if ('done' === e) return {\n          params: t,\n          result: r\n        };\n      }\n    }),\n    u = o.fail = s.filterMap({\n      named: 'fail',\n      fn(_ref3) {\n        let {\n          status: e,\n          params: t,\n          error: r\n        } = _ref3;\n        if ('fail' === e) return {\n          params: t,\n          error: r\n        };\n      }\n    }),\n    p = o.doneData = f.map({\n      named: 'doneData',\n      fn: _ref4 => {\n        let {\n          result: e\n        } = _ref4;\n        return e;\n      }\n    }),\n    m = o.failData = u.map({\n      named: 'failData',\n      fn: _ref5 => {\n        let {\n          error: e\n        } = _ref5;\n        return e;\n      }\n    }),\n    h = a({\n      scope: {\n        handlerId: G(l, 'sid'),\n        handler: o.defaultConfig.handler || (() => r(0, `no handler used in ${o.getType()}`))\n      },\n      node: [Oe((e, t, r) => {\n        let n = t,\n          a = n.handler;\n        if (U(r)) {\n          let e = U(r).handlers[n.handlerId];\n          e && (a = e);\n        }\n        return e.handler = a, e;\n      }, 0, 1), Oe((_ref6, a, i) => {\n        let {\n          params: e,\n          req: t,\n          handler: r,\n          args: n = [e]\n        } = _ref6;\n        let o = xt(i),\n          l = zt(e, t, 1, s, i, o),\n          f = zt(e, t, 0, s, i, o),\n          [u, d] = St(r, f, n);\n        u && (be(d) && ve(d.then) ? d.then(l, f) : l(d));\n      }, 0, 1)],\n      meta: {\n        op: 'fx',\n        fx: 'runner'\n      }\n    });\n  l.scope.runner = h, oe(l.seq, Oe((e, _ref7, r) => {\n    let {\n      runner: t\n    } = _ref7;\n    let n = H(r) ? {\n      params: e,\n      req: {\n        rs(e) {},\n        rj(e) {}\n      }\n    } : e;\n    return i({\n      target: t,\n      params: n,\n      defer: 1,\n      scope: U(r)\n    }), n.params;\n  }, 0, 1)), o.create = e => {\n    let t = g(),\n      r = {\n        params: e,\n        req: t\n      };\n    if (Ke) {\n      if (!Xe) {\n        let e = Ke;\n        t.req.finally(() => {\n          et(e);\n        }).catch(() => {});\n      }\n      i({\n        target: o,\n        params: r,\n        scope: Ke\n      });\n    } else i(o, r);\n    return t.req;\n  };\n  let y = o.inFlight = c(0, {\n    serialize: 'ignore'\n  }).on(o, e => e + 1).on(s, e => e - 1).map({\n    fn: e => e,\n    named: 'inFlight'\n  });\n  J(s, 'needFxCounter', 'dec'), J(o, 'needFxCounter', 1);\n  let b = o.pending = y.map({\n    fn: e => e > 0,\n    named: 'pending'\n  });\n  return he(o, [s, f, u, p, m, b, y]), null != n && n.domain && n.domain.hooks.effect(o), o;\n}\nfunction y(e) {\n  let t;\n  [e, t] = f(e, 1);\n  let {\n      source: r,\n      effect: n,\n      mapParams: a\n    } = e,\n    o = h(e, t);\n  J(o, 'attached', 1);\n  let l,\n    {\n      runner: u\n    } = _(o).scope,\n    d = Oe((e, t, n) => {\n      let l,\n        {\n          params: s,\n          req: f,\n          handler: u\n        } = e,\n        d = o.finally,\n        c = xt(n),\n        p = zt(s, f, 0, d, n, c),\n        m = n.a,\n        g = ee(u),\n        h = 1;\n      if (a ? [h, l] = St(a, p, [s, m]) : l = r && g ? m : s, h) {\n        if (!g) return e.args = [m, l], 1;\n        i({\n          target: u,\n          params: {\n            params: l,\n            req: {\n              rs: zt(s, f, 1, d, n, c),\n              rj: p\n            }\n          },\n          page: n.page,\n          defer: 1\n        });\n      }\n    }, 1, 1);\n  if (r) {\n    let e;\n    Y(r) ? (e = r, he(e, [o])) : (e = p(r), he(o, [e])), l = [Fe(T(e)), d];\n  } else l = [d];\n  u.seq.splice(1, 0, ...l), o.use(n);\n  let c = H(n);\n  return c && (Object.assign(K(o), s(o.shortName, c)), o.defaultConfig.parent = c), yt(n, o, \"effect\"), o;\n}\nfunction b() {\n  for (var _len5 = arguments.length, t = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    t[_key5] = arguments[_key5];\n  }\n  let [[r, n], a] = f(t),\n    i = {};\n  return e(n, (e, t) => {\n    let n = i[t] = d(t, {\n      parent: H(r),\n      config: a\n    });\n    r.on(n, e), yt(r, n);\n  }), i;\n}\nfunction v(r, n) {\n  let o = st({\n      or: n,\n      and: 'string' == typeof r ? {\n        name: r\n      } : r\n    }),\n    l = a({\n      family: {\n        type: \"domain\"\n      },\n      regional: 1,\n      parent: (null == o ? void 0 : o.domain) || (null == o ? void 0 : o.parent)\n    }),\n    s = {\n      history: {},\n      graphite: l,\n      hooks: {}\n    };\n  l.meta = bt(\"domain\", s, {\n    parent: (null == o ? void 0 : o.domain) || (null == o ? void 0 : o.parent),\n    or: o\n  }), e({\n    Event: d,\n    Effect: h,\n    Store: c,\n    Domain: v\n  }, (e, r) => {\n    let n = r.toLowerCase(),\n      a = d({\n        named: `on${r}`\n      });\n    s.hooks[n] = a;\n    let o = new Set();\n    s.history[`${n}s`] = o, a.create = e => (i(a, e), e), oe(_(a).seq, Oe((e, t, r) => (r.scope = null, e))), a.watch(e => {\n      he(s, [e]), o.add(e), e.ownerSet || (e.ownerSet = o), H(e) || (e.parent = s);\n    }), he(s, [a]), s[`onCreate${r}`] = e => (t(o, e), a.watch(e)), s[`create${r}`] = s[n] = (t, r) => {\n      let n = st({\n        and: r,\n        or: t\n      });\n      return null != n && n.domain ? e(t, r) : a(e(t, {\n        parent: s,\n        or: n\n      }));\n    };\n  });\n  let f = H(s);\n  return f && e(s.hooks, (e, t) => mt(e, f.hooks[t])), null != o && o.domain && o.domain.hooks.domain(s), s;\n}\nfunction k(e) {\n  we(e);\n  let t = E in e ? e[E]() : e;\n  r(t.subscribe, 'expect observable to have .subscribe');\n  let n = d(),\n    a = pt(n);\n  return t.subscribe({\n    next: n,\n    error: a,\n    complete: a\n  }), n;\n}\nfunction w(e, t) {\n  xe(e, 'merge', 'first argument');\n  let r = d({\n    name: o(e, 'merge'),\n    derived: 1,\n    and: t\n  });\n  return mt(e, r, [], 'merge'), r;\n}\nfunction S(e, n) {\n  let a = 0;\n  return t(jt, t => {\n    t in e && (r(null != e[t], Ct(n, t)), a = 1);\n  }), a;\n}\nfunction x() {\n  for (var _len6 = arguments.length, e = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    e[_key6] = arguments[_key6];\n  }\n  let t,\n    r,\n    n,\n    a,\n    [[i, o, l], s] = f(e),\n    u = 1;\n  return ke(o) && be(i) && S(i, \"sample\") && (o = i.clock, l = i.fn, u = !i.greedy, a = i.filter, t = i.target, r = i.name, n = i.sid, i = i.source), $t(\"sample\", o, i, a, t, l, r, s, u, 1, 0, n);\n}\nfunction z() {\n  for (var _len7 = arguments.length, e = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    e[_key7] = arguments[_key7];\n  }\n  let [[t, r], n] = f(e);\n  return r || (r = t, t = r.source), S(r, 'guard'), $t('guard', r.clock, t, r.filter, r.target, null, r.name, n, !r.greedy, 0, 1);\n}\nfunction M(t, r, n) {\n  if (Y(t)) return le(0, 'restore($store)'), t;\n  if (Z(t) || ee(t)) {\n    let e = H(t),\n      a = c(r, {\n        parent: e,\n        name: t.shortName,\n        and: n\n      });\n    return mt(ee(t) ? t.doneData : t, a), e && e.hooks.store(a), a;\n  }\n  let a = Array.isArray(t) ? [] : {};\n  return e(t, (e, t) => a[t] = Y(e) ? e : c(e, {\n    name: t\n  })), a;\n}\nfunction j() {\n  for (var _len8 = arguments.length, t = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    t[_key8] = arguments[_key8];\n  }\n  let n,\n    i,\n    o = 'split',\n    [[l, s], c] = f(t),\n    p = !s;\n  p && (n = l.cases, s = l.match, i = l.clock, l = l.source);\n  let m = Y(s),\n    g = !Q(s) && ve(s),\n    h = !m && !g && be(s);\n  r(Q(l), 'source must be a unit'), n || (n = {}), p ? e(n, (e, t) => ze(o, e, `cases.${t}`)) : (r(h, 'match should be an object'), e(s, (e, t) => n[t] = d({\n    derived: 1,\n    and: c\n  })), n.__ = d({\n    derived: 1,\n    and: c\n  }));\n  let y,\n    b = new Set([].concat(l, i || [], Object.values(n))),\n    v = Object.keys(m || g ? n : s);\n  if (m || g) m && b.add(s), y = [m && Fe(T(s), 0, 1), qe({\n    safe: m,\n    filter: 1,\n    pure: !m,\n    fn(e, t, r) {\n      let n = String(m ? r.a : s(e));\n      qt(t, ae(v, n) ? n : '__', e, r);\n    }\n  })];else if (h) {\n    let t = Re({});\n    t.type = 'shape';\n    let r,\n      n = [];\n    e(s, (e, a) => {\n      if (Q(e)) {\n        r = 1, oe(n, a), b.add(e);\n        let i = mt(e, [], [Fe(t), Oe((e, t, _ref8) => {\n          let {\n            a: r\n          } = _ref8;\n          return r[a] = e;\n        })]);\n        if (Y(e)) {\n          t.current[a] = e.getState();\n          let r = T(e);\n          _e(t, {\n            from: r,\n            field: a,\n            type: 'field'\n          }), u('splitMatchStore', r, i);\n        }\n      }\n    }), r && u('splitBase', t), y = [r && Fe(t, 0, 1), De((e, t, r) => {\n      for (let a = 0; a < v.length; a++) {\n        let i = v[a];\n        if (ae(n, i) ? r.a[i] : s[i](e)) return void qt(t, i, e, r);\n      }\n      qt(t, '__', e, r);\n    }, 1)];\n  } else r(0, 'expect match to be unit, function or object');\n  let k = a({\n    meta: {\n      op: o\n    },\n    parent: i ? [] : l,\n    scope: n,\n    node: y,\n    family: {\n      owners: Array.from(b)\n    },\n    regional: 1\n  });\n  if (i && $t(o, i, l, null, k, null, o, c, 0, 0, 0), !p) return n;\n}\nfunction C(e, _ref9) {\n  let {\n    scope: t,\n    params: r\n  } = _ref9;\n  if (!Q(e)) return Promise.reject(new Error('first argument should be unit'));\n  if (!ee(e) && !Z(e) && !Y(e)) return Promise.reject(new Error('first argument accepts only effects, events and stores'));\n  let n = g();\n  n.parentFork = Ke;\n  let {\n    fxCount: a\n  } = t;\n  oe(a.scope.defers, n);\n  let o = [e],\n    l = [];\n  return oe(l, ee(e) ? {\n    params: r,\n    req: {\n      rs(e) {\n        n.value = {\n          status: 'done',\n          value: e\n        };\n      },\n      rj(e) {\n        n.value = {\n          status: 'fail',\n          value: e\n        };\n      }\n    }\n  } : r), oe(o, a), oe(l, null), i({\n    target: o,\n    params: l,\n    scope: t\n  }), n.req;\n}\nfunction $(e, r) {\n  let n = [];\n  (function e(a) {\n    ae(n, a) || (oe(n, a), \"store\" === G(a, 'op') && G(a, 'sid') && r(a, G(a, 'sid')), t(a.next, e), t(V(a), e), t(L(a), e));\n  })(e);\n}\nfunction A(e, n) {\n  let a = Array.isArray(e) ? new Map(e) : e;\n  if (a instanceof Map) {\n    let e = {};\n    return t(a, (t, a) => {\n      r(Q(a), 'Map key should be a unit'), n && n(a, t), r(a.sid, 'unit should have a sid'), r(!(a.sid in e), 'duplicate sid found'), e[a.sid] = t;\n    }), e;\n  }\n  return a;\n}\nfunction I(e, n) {\n  let i,\n    o = e;\n  te(e) && (i = e, o = n);\n  let l = (e => {\n    let r = a({\n        scope: {\n          defers: [],\n          inFlight: 0,\n          fxID: 0\n        },\n        node: [Oe((e, t, r) => {\n          H(r) ? 'dec' === G(H(r).node, 'needFxCounter') ? t.inFlight -= 1 : (t.inFlight += 1, t.fxID += 1) : t.fxID += 1;\n        }), qe({\n          priority: \"sampler\",\n          batch: 1\n        }), Oe((e, r) => {\n          let {\n            defers: n,\n            fxID: a\n          } = r;\n          r.inFlight > 0 || 0 === n.length || Promise.resolve().then(() => {\n            r.fxID === a && t(n.splice(0, n.length), e => {\n              et(e.parentFork), e.rs(e.value);\n            });\n          });\n        }, 0, 1)]\n      }),\n      n = a({\n        node: [Oe((e, t, r) => {\n          let n = H(r);\n          if (n) {\n            let t = n.node;\n            if (!G(t, 'isCombine') || H(n) && 'combine' !== G(H(n).node, 'op')) {\n              let n = U(r),\n                a = t.scope.state.id,\n                i = G(t, 'sid');\n              n.sidIdMap[i] = a, n.sidValuesMap[i] = e;\n              let o = G(t, 'serialize');\n              o && 'ignore' !== o && (n.sidSerializeMap[i] = o.write);\n            }\n          }\n        })]\n      }),\n      i = a({\n        node: [Oe((e, t, r) => {\n          let n = U(r);\n          if (n) {\n            let e = H(r);\n            e && (!G(e.node, 'isCombine') || H(e) && 'combine' !== G(H(e).node, 'op')) && (n.warnSerialize = 1);\n          }\n        })]\n      }),\n      o = {\n        cloneOf: e,\n        reg: {},\n        sidValuesMap: {},\n        sidIdMap: {},\n        sidSerializeMap: {},\n        getState(e) {\n          if ('current' in e) return nt(Ze, o, null, e).current;\n          let t = _(e);\n          return nt(Ze, o, t, t.scope.state, 1).current;\n        },\n        kind: \"scope\",\n        graphite: a({\n          family: {\n            type: \"domain\",\n            links: [r, n, i]\n          },\n          meta: {\n            unit: 'fork'\n          },\n          scope: {\n            forkInFlightCounter: r\n          }\n        }),\n        additionalLinks: {},\n        handlers: {},\n        fxCount: r,\n        storeChange: n,\n        warnSerializeNode: i,\n        activeEffects: []\n      };\n    return o;\n  })(i);\n  if (o) {\n    let e = o.scope;\n    if (e) {\n      let r = e.activeEffects;\n      e.activeEffects = [], l.activeEffects = r, t(r, e => e.ref = l);\n    }\n    if (o.values) {\n      let e = A(o.values, e => r(Y(e), 'Values map can contain only stores as keys'));\n      Object.assign(l.sidValuesMap, e), l.fromSerialize = !(Array.isArray(o.values) || o.values instanceof Map);\n    }\n    o.handlers && (l.handlers = A(o.handlers, e => r(ee(e), \"Handlers map can contain only effects as keys\")));\n  }\n  return l;\n}\nfunction q(e, _ref10) {\n  let {\n    values: t\n  } = _ref10;\n  r(be(t), 'values property should be an object');\n  let n,\n    a,\n    o,\n    l = A(t),\n    s = Object.getOwnPropertyNames(l),\n    f = [],\n    u = [];\n  re(e) ? (n = e, o = 1, r(n.cloneOf, 'scope should be created from domain'), a = _(n.cloneOf)) : te(e) ? a = _(e) : r(0, 'first argument of hydrate should be domain or scope'), $(a, (e, t) => {\n    if (ae(s, t)) {\n      oe(f, e);\n      let r = G(e, 'serialize');\n      r && 'ignore' !== r && (l[t] = r.read(l[t])), oe(u, l[t]);\n    }\n  }), i({\n    target: f,\n    params: u,\n    scope: n\n  }), o && Object.assign(n.sidValuesMap, l);\n}\nfunction N(e) {\n  let {\n    scope: t,\n    safe: n\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  r(t || Ke || n, 'scopeBind cannot be called outside of forked .watch');\n  let a = t || Ke;\n  return ee(e) ? t => {\n    let r = g();\n    return i({\n      target: e,\n      params: {\n        params: t,\n        req: r\n      },\n      scope: a\n    }), r.req;\n  } : t => (i({\n    target: e,\n    params: t,\n    scope: a\n  }), t);\n}\nfunction O(t) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  t.warnSerialize && console.error('There is a store without sid in this scope, its value is omitted');\n  let a = n.ignore ? n.ignore.map(_ref11 => {\n      let {\n        sid: e\n      } = _ref11;\n      return e;\n    }) : [],\n    i = {};\n  return e(t.sidValuesMap, (e, r) => {\n    if (ae(a, r)) return;\n    let n = t.sidIdMap[r];\n    i[r] = (t.sidSerializeMap[r] || Ot)(n && n in t.reg ? t.reg[n].current : e);\n  }), 'onlyChanges' in n && !n.onlyChanges && (r(t.cloneOf, 'scope should be created from domain'), $(_(t.cloneOf), (e, r) => {\n    r in i || ae(a, r) || G(e, 'isCombine') || 'ignore' === G(e, 'serialize') || (i[r] = t.getState(e));\n  })), i;\n}\nfunction F(_ref12) {\n  let {\n    unit: e,\n    fn: t,\n    scope: r\n  } = _ref12;\n  let n = [Ee.run({\n    fn: e => t(e)\n  })];\n  if (r) {\n    let t = a({\n        node: n\n      }),\n      i = e.graphite.id,\n      o = r.additionalLinks,\n      l = o[i] || [];\n    return o[i] = l, l.push(t), D(() => {\n      let e = l.indexOf(t);\n      -1 !== e && l.splice(e, 1), ct(t);\n    });\n  }\n  {\n    let t = a({\n      node: n,\n      parent: [e],\n      family: {\n        owners: e\n      }\n    });\n    return D(() => {\n      ct(t);\n    });\n  }\n}\nfunction D(e) {\n  let t = () => e();\n  return t.unsubscribe = () => e(), t;\n}\nlet E = 'undefined' != typeof Symbol && Symbol.observable || '@@observable',\n  R = 'map',\n  P = 'stack',\n  _ = e => e.graphite || e,\n  V = e => e.family.owners,\n  L = e => e.family.links,\n  T = e => e.stateRef,\n  B = e => e.value,\n  W = e => e.subscribers,\n  H = e => e.parent,\n  U = e => e.scope,\n  G = (e, t) => _(e).meta[t],\n  J = (e, t, r) => _(e).meta[t] = r,\n  K = e => e.compositeName,\n  Q = e => (ve(e) || be(e)) && 'kind' in e;\nconst X = e => t => Q(t) && t.kind === e;\nlet Y = X(\"store\"),\n  Z = X(\"event\"),\n  ee = X(\"effect\"),\n  te = X(\"domain\"),\n  re = X(\"scope\");\nvar ne = {\n  __proto__: null,\n  unit: Q,\n  store: Y,\n  event: Z,\n  effect: ee,\n  domain: te,\n  scope: re,\n  attached: e => ee(e) && 1 == G(e, 'attached')\n};\nlet ae = (e, t) => e.includes(t),\n  ie = (e, t) => {\n    let r = e.indexOf(t);\n    -1 !== r && e.splice(r, 1);\n  },\n  oe = (e, t) => e.push(t),\n  le = (e, t, r) => !e && console.error(`${t} is deprecated${r ? `, use ${r} instead` : ''}`);\nconst se = () => {\n  let e = 0;\n  return () => \"\" + ++e;\n};\nlet fe = se(),\n  ue = se(),\n  de = se(),\n  ce = null,\n  pe = () => ce && ce.template,\n  me = e => (e && ce && ce.sidRoot && (e = `${ce.sidRoot}|${e}`), e),\n  ge = _ref13 => {\n    let {\n      sid: e,\n      name: t,\n      loc: r,\n      method: i,\n      fn: o\n    } = _ref13;\n    return n(a({\n      meta: {\n        sidRoot: me(e),\n        name: t,\n        loc: r,\n        method: i\n      }\n    }), o);\n  },\n  he = (e, r) => {\n    let n = _(e);\n    t(r, e => {\n      let t = _(e);\n      \"domain\" !== n.family.type && (t.family.type = \"crosslink\"), oe(V(t), n), oe(L(n), t);\n    });\n  },\n  ye = function () {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    return (Array.isArray(e) ? e : [e]).flat().map(_);\n  },\n  be = e => 'object' == typeof e && null !== e,\n  ve = e => 'function' == typeof e,\n  ke = e => void 0 === e,\n  we = e => r(be(e) || ve(e), 'expect first argument be an object');\nconst Se = (e, t, n, a) => r(!(!be(e) && !ve(e) || !('family' in e) && !('graphite' in e)), `${t}: expect ${n} to be a unit (store, event or effect)${a}`);\nlet xe = (e, r, n) => {\n    Array.isArray(e) ? t(e, (e, t) => Se(e, r, `${t} item of ${n}`, '')) : Se(e, r, n, ' or array of units');\n  },\n  ze = function (e, r) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"target\";\n    return t(ye(r), t => le(!G(t, 'derived'), `${e}: derived unit in \"${n}\"`, \"createEvent/createStore\"));\n  },\n  Me = (e, _ref14, _ref15) => {\n    let {\n      fn: t\n    } = _ref14;\n    let {\n      a: r\n    } = _ref15;\n    return t(e, r);\n  },\n  je = (e, _ref16, _ref17) => {\n    let {\n      fn: t\n    } = _ref16;\n    let {\n      a: r\n    } = _ref17;\n    return t(r, e);\n  },\n  Ce = (e, _ref18) => {\n    let {\n      fn: t\n    } = _ref18;\n    return t(e);\n  };\nconst $e = (e, t, r, n) => {\n  let a = {\n    id: ue(),\n    type: e,\n    data: t\n  };\n  return r && (a.order = {\n    priority: r\n  }, n && (a.order.barrierID = ++Ae)), a;\n};\nlet Ae = 0,\n  Ie = _ref19 => {\n    let {\n      from: e = \"store\",\n      store: t,\n      target: r,\n      to: n = r ? \"store\" : P,\n      batch: a,\n      priority: i\n    } = _ref19;\n    return $e('mov', {\n      from: e,\n      store: t,\n      to: n,\n      target: r\n    }, i, a);\n  },\n  qe = _ref20 => {\n    let {\n      fn: e,\n      batch: t,\n      priority: r,\n      safe: n = 0,\n      filter: a = 0,\n      pure: i = 0\n    } = _ref20;\n    return $e('compute', {\n      fn: e,\n      safe: n,\n      filter: a,\n      pure: i\n    }, r, t);\n  },\n  Ne = _ref21 => {\n    let {\n      fn: e\n    } = _ref21;\n    return qe({\n      fn: e,\n      priority: \"effect\"\n    });\n  },\n  Oe = (e, t, r) => qe({\n    fn: e,\n    safe: 1,\n    filter: t,\n    priority: r && \"effect\"\n  }),\n  Fe = (e, t, r) => Ie({\n    store: e,\n    to: t ? P : \"a\",\n    priority: r && \"sampler\",\n    batch: 1\n  }),\n  De = function () {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Ce;\n    let t = arguments.length > 1 ? arguments[1] : undefined;\n    return qe({\n      fn: e,\n      pure: 1,\n      filter: t\n    });\n  },\n  Ee = {\n    mov: Ie,\n    compute: qe,\n    filter: _ref22 => {\n      let {\n        fn: e,\n        pure: t\n      } = _ref22;\n      return qe({\n        fn: e,\n        filter: 1,\n        pure: t\n      });\n    },\n    run: Ne\n  },\n  Re = e => ({\n    id: ue(),\n    current: e\n  }),\n  Pe = _ref23 => {\n    let {\n      current: e\n    } = _ref23;\n    return e;\n  },\n  _e = (e, t) => {\n    e.before || (e.before = []), oe(e.before, t);\n  },\n  Ve = null;\nconst Le = (e, t) => {\n    if (!e) return t;\n    if (!t) return e;\n    let r;\n    return (e.v.type === t.v.type && e.v.id > t.v.id || Ge(e.v.type) > Ge(t.v.type)) && (r = e, e = t, t = r), r = Le(e.r, t), e.r = e.l, e.l = r, e;\n  },\n  Te = [];\nlet Be = 0;\nfor (; Be < 6;) oe(Te, {\n  first: null,\n  last: null,\n  size: 0\n}), Be += 1;\nconst We = () => {\n    for (let e = 0; e < 6; e++) {\n      let t = Te[e];\n      if (t.size > 0) {\n        if (3 === e || 4 === e) {\n          t.size -= 1;\n          let e = Ve.v;\n          return Ve = Le(Ve.l, Ve.r), e;\n        }\n        1 === t.size && (t.last = null);\n        let r = t.first;\n        return t.first = r.r, t.size -= 1, r.v;\n      }\n    }\n  },\n  He = (e, t, r, n, a, i) => Ue(0, {\n    a: null,\n    b: null,\n    node: r,\n    parent: n,\n    value: a,\n    page: t,\n    scope: i\n  }, e),\n  Ue = function (e, t, r) {\n    let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let a = Ge(r),\n      i = Te[a],\n      o = {\n        v: {\n          idx: e,\n          stack: t,\n          type: r,\n          id: n\n        },\n        l: null,\n        r: null\n      };\n    3 === a || 4 === a ? Ve = Le(Ve, o) : (0 === i.size ? i.first = o : i.last.r = o, i.last = o), i.size += 1;\n  },\n  Ge = e => {\n    switch (e) {\n      case 'child':\n        return 0;\n      case 'pure':\n        return 1;\n      case 'read':\n        return 2;\n      case \"barrier\":\n        return 3;\n      case \"sampler\":\n        return 4;\n      case \"effect\":\n        return 5;\n      default:\n        return -1;\n    }\n  },\n  Je = new Set();\nlet Ke,\n  Qe = 1,\n  Xe = 0,\n  Ye = 0,\n  Ze = null,\n  et = e => {\n    Ke = e;\n  },\n  tt = e => {\n    Ze = e;\n  };\nconst rt = (e, t) => {\n  if (e) {\n    for (; e && !e.reg[t];) e = H(e);\n    if (e) return e;\n  }\n  return null;\n};\nlet nt = (e, t, r, n, a) => {\n  let i = rt(e, n.id);\n  return i ? i.reg[n.id] : t ? (ot(t, n, a), t.reg[n.id]) : n;\n};\nconst at = e => e;\nlet ot = (e, r, n, a, i) => {\n  var o;\n  let l = e.reg,\n    s = r.sid,\n    f = null == r || null === (o = r.meta) || void 0 === o ? void 0 : o.serialize;\n  if (l[r.id]) return;\n  let u = {\n    id: r.id,\n    current: r.current,\n    meta: r.meta\n  };\n  if (s && s in e.sidValuesMap && !(s in e.sidIdMap)) u.current = (e.fromSerialize && 'ignore' !== f && (null == f ? void 0 : f.read) || at)(e.sidValuesMap[s]);else if (r.before && !i) {\n    let i = 0,\n      o = n || !r.noInit || a;\n    t(r.before, t => {\n      switch (t.type) {\n        case R:\n          {\n            let r = t.from;\n            if (r || t.fn) {\n              r && ot(e, r, n, a);\n              let i = r && l[r.id].current;\n              o && (u.current = t.fn ? t.fn(i) : i);\n            }\n            break;\n          }\n        case 'field':\n          i || (i = 1, u.current = Array.isArray(u.current) ? [...u.current] : {\n            ...u.current\n          }), ot(e, t.from, n, a), o && (u.current[t.field] = l[l[t.from.id].id].current);\n      }\n    });\n  }\n  s && (e.sidIdMap[s] = r.id), l[r.id] = u;\n};\nconst lt = (e, t, r) => {\n  try {\n    return t(B(r), e.scope, r);\n  } catch (t) {\n    console.error(t), e.fail = 1;\n  }\n};\nlet st = function (t) {\n  let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return be(t) && (st(t.or, r), e(t, (e, t) => {\n    ke(e) || 'or' === t || 'and' === t || (r[t] = e);\n  }), st(t.and, r)), r;\n};\nconst ft = (e, t) => {\n    ie(e.next, t), ie(V(e), t), ie(L(e), t);\n  },\n  ut = (e, t, r) => {\n    let n;\n    e.next.length = 0, e.seq.length = 0, e.scope = null;\n    let a = L(e);\n    for (; n = a.pop();) ft(n, e), (t || r && 'sample' !== G(e, 'op') || \"crosslink\" === n.family.type) && ut(n, t, 'on' !== G(n, 'op') && r);\n    for (a = V(e); n = a.pop();) ft(n, e), r && \"crosslink\" === n.family.type && ut(n, t, 'on' !== G(n, 'op') && r);\n  },\n  dt = e => e.clear();\nlet ct = function (e) {\n    let {\n      deep: t\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let r = 0;\n    if (e.ownerSet && e.ownerSet.delete(e), Y(e)) dt(W(e));else if (te(e)) {\n      r = 1;\n      let t = e.history;\n      dt(t.events), dt(t.effects), dt(t.stores), dt(t.domains);\n    }\n    ut(_(e), !!t, r);\n  },\n  pt = e => {\n    let t = () => ct(e);\n    return t.unsubscribe = t, t;\n  },\n  mt = (e, t, r, n, i) => a({\n    node: r,\n    parent: e,\n    child: t,\n    scope: {\n      fn: i\n    },\n    meta: {\n      op: n\n    },\n    family: {\n      owners: [e, t],\n      links: t\n    },\n    regional: 1\n  }),\n  gt = e => {\n    let t = 'forward',\n      [{\n        from: r,\n        to: n\n      }, i] = f(e, 1);\n    return xe(r, t, '\"from\"'), xe(n, t, '\"to\"'), ze(t, n, 'to'), pt(a({\n      parent: r,\n      child: n,\n      meta: {\n        op: t,\n        config: i\n      },\n      family: {},\n      regional: 1\n    }));\n  },\n  ht = (e, t) => (r(ve(t), '.watch argument should be a function'), pt(a({\n    scope: {\n      fn: t\n    },\n    node: [Ne({\n      fn: Ce\n    })],\n    parent: e,\n    meta: {\n      op: 'watch'\n    },\n    family: {\n      owners: e\n    },\n    regional: 1\n  }))),\n  yt = function (e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"event\";\n    H(e) && H(e).hooks[r](t);\n  },\n  bt = (e, t, r) => {\n    let n = st(r),\n      a = \"domain\" === e,\n      i = fe(),\n      {\n        sid: o = null,\n        named: l = null,\n        domain: f = null,\n        parent: u = f\n      } = n,\n      d = l || n.name || (a ? '' : i),\n      c = s(d, u),\n      p = {\n        op: t.kind = e,\n        name: t.shortName = d,\n        sid: t.sid = me(o),\n        named: l,\n        unitId: t.id = i,\n        serialize: n.serialize,\n        derived: n.derived,\n        config: n\n      };\n    if (t.parent = u, t.compositeName = c, t.defaultConfig = n, t.thru = e => (le(0, 'thru', 'js pipe'), e(t)), t.getType = () => c.fullName, !a) {\n      t.subscribe = e => (we(e), t.watch(ve(e) ? e : t => e.next && e.next(t))), t[E] = () => t;\n      let e = pe();\n      e && (p.nativeTemplate = e);\n    }\n    return p;\n  };\nconst vt = (e, t, r, n) => {\n    let a;\n    be(r) && (a = r, r = r.fn);\n    let i = d({\n      name: `${e.shortName} \\u2192 *`,\n      derived: 1,\n      and: a\n    });\n    return mt(e, i, n, t, r), i;\n  },\n  kt = (e, t, r, n, a) => {\n    let i = T(t),\n      o = Ie({\n        store: i,\n        to: \"a\",\n        priority: 'read'\n      });\n    r === R && (o.data.softRead = 1);\n    let l = [o, De(n)];\n    return u('storeOnMap', i, l, Y(e) && T(e)), mt(e, t, l, r, a);\n  },\n  wt = (t, n, a, i, l) => {\n    let s = t ? e => [...e] : e => ({\n        ...e\n      }),\n      f = t ? [] : {},\n      d = s(f),\n      p = Re(d),\n      m = Re(1);\n    p.type = t ? 'list' : 'shape', p.noInit = 1, u('combineBase', p, m);\n    let g = c(d, {\n        name: o(a),\n        derived: 1,\n        and: i\n      }),\n      h = T(g);\n    h.noInit = 1, J(g, 'isCombine', 1);\n    let y = Fe(p);\n    y.order = {\n      priority: 'barrier'\n    };\n    let b = [Oe((e, t, r) => (r.scope && !r.scope.reg[p.id] && (r.c = 1), e)), y, Ie({\n      store: m,\n      to: 'b'\n    }), Oe((e, _ref24, r) => {\n      let {\n        key: t\n      } = _ref24;\n      if (r.c || e !== r.a[t]) return n && r.b && (r.a = s(r.a)), r.a[t] = e, 1;\n    }, 1), Ie({\n      from: \"a\",\n      target: p\n    }), Ie({\n      from: \"value\",\n      store: 0,\n      target: m\n    }), Ie({\n      from: \"value\",\n      store: 1,\n      target: m,\n      priority: \"barrier\",\n      batch: 1\n    }), Fe(p, 1), l && De()];\n    return e(a, (e, t) => {\n      if (!Y(e)) return r(!Q(e) && !ke(e), `combine expects a store in a field ${t}`), void (d[t] = f[t] = e);\n      f[t] = e.defaultState, d[t] = e.getState();\n      let n = mt(e, g, b, 'combine', l);\n      n.scope.key = t;\n      let a = T(e);\n      _e(p, {\n        type: 'field',\n        field: t,\n        from: a\n      }), u('combineField', a, n);\n    }), g.defaultShape = a, _e(h, {\n      type: R,\n      from: p,\n      fn: l\n    }), pe() || (g.defaultState = l ? h.current = l(d) : f), g;\n  };\nlet St = (e, t, r) => {\n    try {\n      return [1, e(...r)];\n    } catch (e) {\n      return t(e), [0, null];\n    }\n  },\n  xt = e => {\n    let t = U(e),\n      r = {\n        ref: t\n      };\n    return t && oe(t.activeEffects, r), r;\n  },\n  zt = (e, t, r, n, a, o) => l => {\n    o.ref && ie(o.ref.activeEffects, o), i({\n      target: [n, Mt],\n      params: [r ? {\n        status: 'done',\n        params: e,\n        result: l\n      } : {\n        status: 'fail',\n        params: e,\n        error: l\n      }, {\n        value: l,\n        fn: r ? t.rs : t.rj\n      }],\n      defer: 1,\n      page: a.page,\n      scope: o.ref\n    });\n  };\nconst Mt = a({\n    node: [Ne({\n      fn: _ref25 => {\n        let {\n          fn: e,\n          value: t\n        } = _ref25;\n        return e(t);\n      }\n    })],\n    meta: {\n      op: 'fx',\n      fx: 'sidechain'\n    }\n  }),\n  jt = ['source', 'clock', 'target'],\n  Ct = (e, t) => e + `: ${t} should be defined`;\nlet $t = (e, t, n, a, i, o, l, s, f, m, g, h) => {\n  let y = !!i;\n  r(!ke(n) || !ke(t), Ct(e, 'either source or clock'));\n  let b = 0;\n  ke(n) ? b = 1 : Q(n) || (n = p(n)), ke(t) ? t = n : (xe(t, e, 'clock'), Array.isArray(t) && (t = w(t))), b && (n = t), s || l || (l = n.shortName);\n  let v = 'none';\n  (g || a) && (Q(a) ? v = 'unit' : (r(ve(a), '`filter` should be function or unit'), v = 'fn')), i ? (xe(i, e, 'target'), ze(e, i)) : 'none' === v && m && Y(n) && Y(t) ? i = c(o ? o(Pe(T(n)), Pe(T(t))) : Pe(T(n)), {\n    name: l,\n    sid: h,\n    or: s\n  }) : (i = d({\n    name: l,\n    derived: 1,\n    or: s\n  }), u('sampleTarget', _(i)));\n  let k = Re(),\n    S = [];\n  if ('unit' === v) {\n    let [r, n] = It(a, i, t, k, e);\n    S = [...At(n), ...At(r)];\n  }\n  let [x, z] = It(n, i, t, k, e),\n    M = mt(t, i, [u('sampleSourceLoader'), Ie({\n      from: P,\n      target: k\n    }), ...At(z), Fe(x, 1, f), ...S, Fe(k), 'fn' === v && De((e, t, _ref26) => {\n      let {\n        a: r\n      } = _ref26;\n      return a(e, r);\n    }, 1), o && De(Me), u('sampleSourceUpward', y)], e, o);\n  return he(n, [M]), Object.assign(M.meta, s, {\n    joint: 1\n  }), i;\n};\nconst At = e => [Fe(e), Oe((e, t, _ref27) => {\n    let {\n      a: r\n    } = _ref27;\n    return r;\n  }, 1)],\n  It = (e, t, r, n, i) => {\n    let o = Y(e),\n      l = o ? T(e) : Re(),\n      s = Re(o);\n    return o || a({\n      parent: e,\n      node: [Ie({\n        from: P,\n        target: l\n      }), Ie({\n        from: \"value\",\n        store: 1,\n        target: s\n      })],\n      family: {\n        owners: [e, t, r],\n        links: t\n      },\n      meta: {\n        op: i\n      },\n      regional: 1\n    }), u('sampleSource', s, l, n), [l, s];\n  },\n  qt = (e, t, r, n) => {\n    let a = e[t];\n    a && i({\n      target: a,\n      params: Array.isArray(a) ? a.map(() => r) : r,\n      defer: 1,\n      stack: n\n    });\n  },\n  Nt = \"22.4.1\",\n  Ot = e => e;\nexport { C as allSettled, y as attach, ct as clearNode, p as combine, b as createApi, v as createDomain, h as createEffect, d as createEvent, a as createNode, c as createStore, m as createStoreObject, F as createWatch, I as fork, gt as forward, k as fromObservable, z as guard, q as hydrate, ne as is, i as launch, w as merge, M as restore, x as sample, N as scopeBind, O as serialize, l as setStoreName, j as split, Ee as step, Nt as version, ge as withFactory, n as withRegion };","map":{"version":3,"mappings":"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","names":["forIn","obj","cb","key","forEach","list","fn","assert","condition","message","Error","withRegion","unit","regionStack","parent","value","template","getMeta","readTemplate","sidRoot","getParent","createNode","node","from","source","to","target","child","scope","meta","family","familyRaw","type","regional","sources","arrifyNodes","links","owners","seq","item","add","result","id","nextNodeID","next","link","getOwners","owner","getLinks","own","getValue","launch","payload","upsert","pageForLaunch","currentPage","stackForLaunch","forkPageForLaunch","forkPage","params","defer","page","stack","getForkPage","Array","isArray","i","length","pushFirstHeapItem","getGraph","isRoot","stop","skip","reg","lastStartedState","isWatch","isPure","kernelLoop","deleteMin","idx","hasPageReg","hasScopeReg","local","fail","stepn","step","order","priority","barrierID","fullID","barriers","has","pushHeap","delete","data","STACK","store","pageForRef","getPageForRef","initRefInScope","softRead","undefined","readRef","getPageRef","current","pure","computationResult","safe","tryRun","filter","finalValue","nextNode","fxCount","storeChange","warnSerializeNode","additionalLinks","unitObjectName","objOrArr","method","name","comma","is","getCompositeName","fullName","toString","setStoreName","rawName","shortName","Object","assign","createName","path","composite","concat","processArgsToConfig","args","singleArgument","rawConfig","assertObject","metadata","or","childConfig","and","unwrappedNestedValue","isObject","nested","applyTemplate","handlers","createEvent","nameOrConfig","maybeConfig","config","flattenConfig","event","deprecate","oldPage","setCurrentPage","create","finalEvent","graphite","initUnit","watch","watchUnit","map","deriveEvent","MAP","userFnCall","callStack","filterMap","calc","isVoid","prepend","contramapped","createLinkNode","applyParentHook","domain","hooks","createStore","defaultState","props","plainState","createStateRef","updates","named","derived","plainStateId","subscribers","Map","stateRef","getState","reachedPage","targetRef","setState","state","reset","units","on","nodeSet","assertNodeSet","isFunction","trigger","off","getSubscribers","set","createSubscription","updateStore","callARegStack","currentSubscription","get","firstState","lastResult","storeState","innerStore","linkNode","callStackAReg","addRefOp","getStoreState","noInit","eventOrFn","subscription","updateFilter","defaultConfig","upd","_","b","read","a","mov","serializeMeta","ignored","customSerialize","sid","setMeta","serialize","reinit","combine","handler","stores","structStoreShape","shapeReady","noArraySpread","rawHandler","slice","storeCombination","createStoreObject","createDefer","req","Promise","rs","rj","catch","createEffect","instance","kind","use","runner","getCurrent","anyway","finally","done","status","error","doneData","failData","handlerId","getType","scope_","handler_","scopeRef","createScopeRef","onResolve","onSettled","onReject","ok","runFn","then","op","fx","savedFork","setForkPage","inFlight","x","pending","amount","effect","attach","injected","mapParams","attached","runnerSteps","runnerFnStep","computedParams","sourceData","isEffectHandler","splice","parentDomain","createApi","setters","createDomain","history","Event","Effect","Store","Domain","factory","tag","lowerCaseTag","toLowerCase","onCreateUnit","Set","ownerSet","hook","fromObservable","observable","observableItem","observableSymbol","subscribe","disposer","complete","merge","validateSampleConfig","atLeastOneFieldExists","sampleConfigFields","field","fieldErrorMessage","sample","clock","batched","greedy","createSampling","guard","restore","split","targets","METHOD","match","configForm","cases","matchIsUnit","matchIsFunction","matchIsShape","assertTarget","__","splitterSeq","values","caseNames","keys","compute","scopeTargets","String","launchCase","includes","lastValues","needBarrier","storeOrFn","updater","storeRef","caseName","splitterNode","allSettled","start","ctx","reject","parentFork","defers","launchUnits","launchParams","traverseStores","root","visit","normalizeValues","assertEach","mapOrRecordValues","fork","domainOrConfig","optiionalConfig","forkInFlightCounter","fxID","batch","resolve","storeStack","storeNode","sidIdMap","sidValuesMap","sidSerializeMap","write","warnSerialize","resultScope","cloneOf","activeEffects","oldScope","ref","valuesSidMap","fromSerialize","hydrate","traverseTarget","needToAssign","normalizedValues","valuesSidList","getOwnPropertyNames","storeNodes","storeValues","serializer","scopeBind","savedForkPage","console","ignoredStores","ignore","noopSerializer","onlyChanges","createWatch","run","scopeLinks","push","indexOf","clearNode","callback","unsubscribe","Symbol","graph","val","compositeName","__proto__","removeItem","pos","subject","suggestion","idCount","nextUnitID","nextStepID","readSidRoot","withFactory","loc","ownerUnit","_link","flat","assertNodeSetItem","valueName","reason","targetField","cmd","nextBarrierID","isEffect","toStack","samplerPriority","isFilter","before","heap","ret","v","getPriority","r","l","queue","ix","first","last","size","bucket","t","newForkPage","newPage","isGetState","noopParser","sourceRef","isKernelCall","refsMap","_sourceRef$meta","isFresh","err","part","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","events","effects","domains","scopeFn","forward","opts","hookType","isDomain","unitId","thru","observer","nativeTemplate","mapped","caller","reader","needSpread","clone","stateNew","rawShape","storeStateRef","rawShapeReader","c","childRef","defaultShape","sidechain","targetMayBeStore","filterRequired","isUpward","sourceIsClock","filterType","clockState","filterNodes","filterRef","hasFilter","syncSourceState","readAndFilter","hasSource","jointNode","src","joint","isSourceStore"],"sources":["/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/collection.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/throw.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/region.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/createNode.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/tag.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/kernel.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/naming.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/config.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/template.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/createUnit.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/combine.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/defer.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/createEffect.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/attach.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/createApi.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/createDomain.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/fromObservable.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/merge.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/sample.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/guard.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/restore.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/split.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/fork/allSettled.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/fork/util.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/fork/fork.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/fork/createScope.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/fork/hydrate.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/fork/scopeBind.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/fork/serialize.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/createWatch.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/observable.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/getter.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/validate.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/id.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/own.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/is.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/caller.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/step.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/stateRef.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/clearNode.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/subscription.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/forward.ts","/Users/mark/Desktop/Projects/config_generator/node_modules/effector/effector/watch.ts"],"sourcesContent":["export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import type {Template} from '../forest/index.h'\nimport type {NodeUnit} from './index.h'\nimport {getParent, getMeta} from './getter'\nimport {createNode} from './createNode'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: Template | null\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion(unit: NodeUnit, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: getMeta(unit, 'template') || readTemplate(),\n    sidRoot: getMeta(unit, 'sidRoot') || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), name, loc, method},\n  })\n  return withRegion(sidNode, fn)\n}\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nexport const arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef, Stack} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {STORE, EFFECT, SAMPLER, STACK, BARRIER, VALUE, REG_A, MAP} from './tag'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  scope?: Scope | null | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case BARRIER:\n      return 3\n    case SAMPLER:\n      return 4\n    case EFFECT:\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let isPure = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope | void | null) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void\n  stack?: Stack | void\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {\n    isRoot,\n    currentPage,\n    scope: forkPage,\n    isWatch,\n    isPure,\n  }\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = getMeta(node, 'op') === 'watch'\n            isPure = data.pure\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n            isPure = lastStartedState.isPure\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      const forkPage = getForkPage(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem('child', page, nextNode, stack, finalValue, forkPage)\n      })\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'warnSerialize'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.warnSerializeNode,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nconst noopParser = (x: any) => x\n\nexport const initRefInScope = (\n  scope: {\n    reg: Record<string, StateRef>\n    sidValuesMap: Record<string, any>\n    sidIdMap: Record<string, string>\n    fromSerialize?: boolean\n  },\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  const sid = sourceRef.sid\n  const serialize = sourceRef?.meta?.serialize\n  const parser =\n    scope.fromSerialize && serialize !== 'ignore'\n      ? serialize?.read || noopParser\n      : noopParser\n  if (refsMap[sourceRef.id]) return\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n    meta: sourceRef.meta,\n  }\n\n  if (sid && sid in scope.sidValuesMap && !(sid in scope.sidIdMap)) {\n    ref.current = parser(scope.sidValuesMap[sid])\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              const value = from && refsMap[from.id].current\n              if (needToAssign) {\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import type {Store, CommonUnit, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent, getCompositeName} from './getter'\nimport {forIn} from './collection'\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, unit => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit)\n          ? getCompositeName(unit as CommonUnit | Domain).fullName\n          : (unit as any).toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompositeName(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompositeName(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn = template.handlers[method]\n    // @ts-expect-error\n    if (fn) return fn(template, ...args)\n  }\n}\n","import type {Template} from '../forest/index.h'\nimport type {Store, Event, CommonUnit, Effect, Domain} from './unit.h'\nimport type {Subscriber, Config, Cmd, Kind} from './index.h'\n\nimport {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport {calc, mov, read, userFnCall} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n  isPure,\n} from './kernel'\n\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\n\nexport const applyParentHook = (\n  source: CommonUnit,\n  target: CommonUnit,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind: Kind, unit: any, rawConfig: any) => {\n  const config = flattenConfig(rawConfig)\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const {sid = null, named = null, domain = null, parent = domain} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n    config,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => {\n    deprecate(false, 'thru', 'js pipe')\n    return fn(unit)\n  }\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (\n  event: Event<any>,\n  op: 'map' | 'filterMap' | 'filter',\n  fn: Function,\n  node: Cmd[],\n) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = (fn as unknown as {fn: Function}).fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName} → *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate<T>(\n  unit: Event<T> | Effect<T, any, any>,\n  template: Template | null,\n  payload: T,\n  args: any[],\n) {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n  const event = ((payload: Payload, ...args: unknown[]) => {\n    deprecate(\n      !getMeta(event, 'derived'),\n      'call of derived event',\n      'createEvent',\n    )\n    deprecate(!isPure, 'unit call from pure function', 'operators like sample')\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }) as Event<Payload>\n  const template = readTemplate()\n  const finalEvent = Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(EVENT, event, config),\n      regional: true,\n    }),\n    create(params: Payload, _: any[]) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: Function) => deriveEvent(event, MAP, fn, [userFnCall()]),\n    filter: (fn: {fn: Function}) =>\n      //@ts-expect-error\n      deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [\n        userFnCall(callStack, true),\n      ]),\n    filterMap: (fn: Function) =>\n      deriveEvent(event, 'filterMap', fn, [\n        userFnCall(),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: Function) {\n      const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(contramapped, event, [userFnCall()], 'prepend', fn)\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n  if (config?.domain) {\n    config.domain.hooks.event(finalEvent)\n  }\n  return finalEvent\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const config = flattenConfig(props)\n  const plainState = createStateRef(defaultState)\n  const updates = createEvent({named: 'updates', derived: true})\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n  const store = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: State) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: CommonUnit[]) {\n      forEach(units, unit => store.on(unit, () => store.defaultState))\n      return store\n    },\n    on(nodeSet: CommonUnit | CommonUnit[], fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      assert(isFunction(fn), 'second argument should be a function')\n      deprecate(\n        !getMeta(store, 'derived'),\n        '.on in derived store',\n        'createStore',\n      )\n      forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n        store.off(trigger)\n        getSubscribers(store).set(\n          trigger,\n          createSubscription(\n            updateStore(trigger, store, 'on', callARegStack, fn),\n          ),\n        )\n      })\n      return store\n    },\n    off(unit: CommonUnit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: (value: any, prevArg?: any) => any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = (fn as unknown as {fn: (value: any) => any}).fn\n      }\n      deprecate(\n        isVoid(firstState),\n        'second argument of store.map',\n        'updateFilter',\n      )\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!isVoid(storeState)) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName} → *`,\n        derived: true,\n        // @ts-expect-error some mismatch in config types\n        and: config,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStackAReg, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function')\n      return (eventOrFn as CommonUnit).watch((payload: any) =>\n        fn(store.getState(), payload),\n      )\n    },\n  } as unknown as Store<State>\n  const meta = initUnit(STORE, store, config)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => !isVoid(upd) && (upd !== a || b), true),\n      updateFilter && userFnCall(callStackAReg, true),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  const serializeMeta = getMeta(store, 'serialize')\n  const derived = getMeta(store, 'derived')\n  const ignored = serializeMeta === 'ignore'\n  const customSerialize = !serializeMeta || ignored ? false : serializeMeta\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    if (!ignored) setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n\n    if (customSerialize) {\n      plainState.meta = {\n        ...plainState?.meta,\n        serialize: customSerialize,\n      }\n    }\n  }\n  if (!sid && !ignored && !derived) {\n    setMeta(store, 'warnSerialize', true)\n  }\n  assert(\n    derived || !isVoid(defaultState),\n    \"current state can't be undefined, use null instead\",\n  )\n  own(store, [updates])\n  if (config?.domain) {\n    config.domain.hooks.store(store)\n  }\n\n  if (!derived) {\n    store.reinit = createEvent<void>()\n    store.reset(store.reinit)\n  }\n\n  return store\n}\n\nconst updateStore = (\n  from: CommonUnit,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, userFnCall(caller)]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, calc, read, userFnCall} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport type {Config} from './index.h'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = (list: any[]) => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), 'shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj: any,\n  config?: Config,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => [...list] : (obj: any) => ({...obj})\n  const defaultState: Record<string, any> = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const rawShapeReader = read(rawShape)\n  /**\n   * usual ref reading has very high priority, which leads to data races\n   * ref reading for combine should have same \"barrier\" priority but without batching\n   * (thats why order has no \"barrierID\" field, which assume batching)\n   **/\n  rawShapeReader.order = {priority: 'barrier'}\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    rawShapeReader,\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: BARRIER,\n      batch: true,\n    }),\n    read(rawShape, true),\n    fn && userFnCall(),\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args: any[]) {\n  deprecate(false, 'createStoreObject', 'combine')\n  return combine(...args)\n}\n","import type {Defer} from './unit.h'\n\nexport function createDefer(): Defer {\n  const result = {} as Defer\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(() => {})\n  return result\n}\n","import type {Unit, Stack} from './index.h'\nimport type {Effect, Scope} from './unit.h'\nimport {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport {add, removeItem} from './collection'\nimport {flattenConfig} from './config'\n\ntype RunnerData<Params, Done, Fail> = {\n  params: Params\n  req: {\n    rs(data: Done): void\n    rj(data: Fail): void\n  }\n  args?: [params: Params, computedParams: any] | [params: Params]\n  handler?: Function\n}\n\nexport function createEffect<Params, Done, Fail = Error>(\n  nameOrConfig: any,\n  maybeConfig?: any,\n): Effect<Params, Done, Fail> {\n  const config = flattenConfig(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  )\n  const instance = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  ) as unknown as Effect<Params, Done, Fail>\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  //@ts-expect-error\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function')\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createEvent({\n    named: 'finally',\n    derived: true,\n  }))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({\n      status,\n      params,\n      result,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({\n      status,\n      params,\n      error,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: {result: Done}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: {error: Fail}) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handlerId: getMeta(node, 'sid'),\n      handler:\n        instance.defaultConfig.handler ||\n        (() => assert(false, `no handler used in ${instance.getType()}`)),\n    },\n    node: [\n      calc(\n        (upd: RunnerData<Params, Done, Fail>, scope_, stack) => {\n          const scope: {handlerId: string; handler: Function} = scope_ as any\n          let handler = scope.handler\n          if (getForkPage(stack)) {\n            const handler_ = getForkPage(stack)!.handlers[scope.handlerId]\n            if (handler_) handler = handler_\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        (\n          {\n            params,\n            req,\n            handler,\n            args = [params],\n          }: RunnerData<Params, Done, Fail> & {handler: Function},\n          _,\n          stack,\n        ) => {\n          const scopeRef = createScopeRef(stack)\n          const onResolve = onSettled(\n            params,\n            req,\n            true,\n            anyway,\n            stack,\n            scopeRef,\n          )\n          const onReject = onSettled(\n            params,\n            req,\n            false,\n            anyway,\n            stack,\n            scopeRef,\n          )\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc(\n      (params, {runner}, stack) => {\n        const upd: RunnerData<Params, Done, Fail> = getParent(stack)\n          ? {params, req: {rs(data: Done) {}, rj(data: Fail) {}}}\n          : /** empty stack means that this node was launched directly */\n            params\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          scope: getForkPage(stack),\n        })\n        return upd.params\n      },\n      false,\n      true,\n    ),\n  )\n  //@ts-expect-error\n  instance.create = (params: Params) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch({target: instance, params: payload, scope: forkPage})\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {\n    serialize: 'ignore',\n  })\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1)\n    .map({\n      // @ts-expect-error\n      fn: x => x,\n      named: 'inFlight',\n    }))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  if (config?.domain) {\n    config.domain.hooks.effect(instance)\n  }\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data: any) => void,\n  args: any[],\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const createScopeRef = (stack: Stack) => {\n  const scope = getForkPage(stack)\n  const scopeRef = {ref: scope}\n  if (scope) add(scope.activeEffects, scopeRef)\n  return scopeRef\n}\n\nexport const onSettled =\n  (\n    params: any,\n    req: {\n      rs(_: any): void\n      rj(_: any): void\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n    scopeRef: {ref: Scope | void},\n  ) =>\n  (data: any) => {\n    if (scopeRef.ref) removeItem(scopeRef.ref.activeEffects, scopeRef)\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      // WARN! Will broke forest pages as they arent moved to new scope\n      page: stack.page,\n      scope: scopeRef.ref,\n    })\n  }\nconst sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import type {Domain} from './unit.h'\nimport {combine} from './combine'\nimport {createEffect, createScopeRef, onSettled, runFn} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {processArgsToConfig} from './config'\nimport {\n  getGraph,\n  getParent,\n  getStoreState,\n  setMeta,\n  getCompositeName,\n} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {read, calc} from './step'\nimport {launch} from './kernel'\nimport {EFFECT} from './tag'\nimport {createName} from './naming'\n\nexport function attach(config: any) {\n  let injected\n  ;[config, injected] = processArgsToConfig(config, true)\n  let {source, effect, mapParams} = config\n  const attached = createEffect(config, injected)\n  setMeta(attached, 'attached', true)\n  const {runner} = getGraph(attached).scope\n  let runnerSteps\n  const runnerFnStep = calc(\n    (upd, _, stack) => {\n      const {params, req, handler} = upd\n      const anyway = attached.finally\n      const scopeRef = createScopeRef(stack)\n      const rj = onSettled(params, req, false, anyway, stack, scopeRef)\n      const sourceData = stack.a\n      const isEffectHandler = is.effect(handler)\n      let ok = true\n      let computedParams\n      if (mapParams) {\n        ;[ok, computedParams] = runFn(mapParams, rj, [params, sourceData])\n      } else {\n        computedParams = source && isEffectHandler ? sourceData : params\n      }\n      if (ok) {\n        if (isEffectHandler) {\n          launch({\n            target: handler as any,\n            params: {\n              params: computedParams,\n              req: {\n                rs: onSettled(params, req, true, anyway, stack, scopeRef),\n                rj,\n              },\n            },\n            page: stack.page,\n            defer: true,\n          })\n        } else {\n          upd.args = [sourceData, computedParams]\n          return true\n        }\n      }\n    },\n    true,\n    true,\n  )\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(state, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    runnerSteps = [read(getStoreState(state)), runnerFnStep]\n  } else {\n    runnerSteps = [runnerFnStep]\n  }\n  runner.seq.splice(1, 0, ...runnerSteps)\n  attached.use(effect)\n  const parentDomain: Domain | void = getParent(effect)\n  if (parentDomain) {\n    Object.assign(\n      getCompositeName(attached),\n      createName(attached.shortName, parentDomain),\n    )\n    attached.defaultConfig.parent = parentDomain\n  }\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import type {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import type {Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport type {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createNamedEvent,\n  createStore,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {createLinkNode} from './forward'\nimport {add, forEach, forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {calc} from './step'\nimport {flattenConfig} from './config'\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n\n  const node = createNode({\n    family: {type: DOMAIN},\n    regional: true,\n    parent: config?.domain || config?.parent,\n  })\n\n  const domain = {\n    history: {},\n    graphite: node,\n    hooks: {},\n  } as Domain\n\n  node.meta = initUnit(DOMAIN, domain, {\n    parent: config?.domain || config?.parent,\n    or: config,\n  })\n\n  forIn(\n    {\n      Event: createEvent,\n      Effect: createEffect,\n      Store: createStore,\n      Domain: createDomain,\n    },\n    (factory, tag) => {\n      const lowerCaseTag = tag.toLowerCase() as\n        | 'event'\n        | 'effect'\n        | 'store'\n        | 'domain'\n\n      const onCreateUnit = createNamedEvent(`on${tag}`)\n      domain.hooks[lowerCaseTag] = onCreateUnit\n\n      const history = new Set<any>()\n      domain.history[`${lowerCaseTag}s`] = history\n\n      onCreateUnit.create = unit => {\n        launch(onCreateUnit, unit)\n        return unit\n      }\n      add(\n        getGraph(onCreateUnit).seq,\n        calc((upd, _, stack) => {\n          stack.scope = null\n          return upd\n        }),\n      )\n      onCreateUnit.watch(unit => {\n        own(domain, [unit])\n        history.add(unit)\n        if (!unit.ownerSet) unit.ownerSet = history\n        if (!getParent(unit)) unit.parent = domain\n      })\n      own(domain, [onCreateUnit])\n\n      domain[`onCreate${tag}`] = (hook: (unit: any) => any) => {\n        forEach(history, hook)\n        return onCreateUnit.watch(hook)\n      }\n      domain[`create${tag}`] = domain[lowerCaseTag] = (\n        nameOrConfig: any,\n        rawConfig?: Config,\n      ) => {\n        const config = flattenConfig({and: rawConfig, or: nameOrConfig})\n        if (config?.domain) {\n          // @ts-expect-error complicated factory type\n          return factory(nameOrConfig, rawConfig)\n        }\n        // @ts-expect-error complicated factory type\n        return onCreateUnit(factory(nameOrConfig, {parent: domain, or: config}))\n      }\n    },\n  )\n\n  const parent = getParent(domain)\n  if (parent) {\n    forIn(domain.hooks, (from: NodeUnit, key) =>\n      createLinkNode(from, parent.hooks[key]),\n    )\n  }\n  if (config?.domain) {\n    config.domain.hooks.domain(domain)\n  }\n  return domain\n}\n","import {observableSymbol} from './observable'\nimport type {Event} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {assertObject} from './is'\nimport {assert} from './throw'\nimport {createSubscription} from './subscription'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  assert(observableItem.subscribe, 'expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = createSubscription(event)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  units: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  assertNodeSet(units, 'merge', 'first argument')\n  const result = createEvent({\n    name: unitObjectName(units, 'merge'),\n    derived: true,\n    and: config,\n  })\n  createLinkNode(units, result, [], 'merge')\n  return result\n}\n","import type {Cmd, StateRef} from './index.h'\nimport type {CommonUnit, DataCarrier} from './unit.h'\nimport {combine} from './combine'\nimport {mov, userFnCall, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {\n  assertNodeSet,\n  assertTarget,\n  is,\n  isObject,\n  isVoid,\n  isFunction,\n} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\nimport {forEach} from './collection'\nimport {SAMPLE, STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\nimport {own} from './own'\nimport {createLinkNode} from './forward'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config: any, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any[]) {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batched = true\n  let filter\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, SAMPLE)\n  ) {\n    clock = source.clock\n    fn = source.fn\n    batched = !source.greedy\n    filter = source.filter\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  return createSampling(\n    SAMPLE,\n    clock,\n    source,\n    filter,\n    target,\n    fn,\n    name,\n    metadata,\n    batched,\n    true,\n    false,\n    sid,\n  )\n}\n\nexport const createSampling = (\n  method: string,\n  clock: DataCarrier | DataCarrier[] | void,\n  source: DataCarrier | Array<Store<any>> | Record<string, Store<any>> | void,\n  filter: any,\n  target: DataCarrier | DataCarrier[] | void,\n  fn: any,\n  name: string | undefined,\n  metadata: object | void,\n  batched: boolean,\n  targetMayBeStore: boolean,\n  filterRequired: boolean,\n  sid?: string | undefined,\n) => {\n  const isUpward = !!target\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(method, 'either source or clock'),\n  )\n  let sourceIsClock = false\n  if (isVoid(source)) {\n    sourceIsClock = true\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  } else {\n    assertNodeSet(clock, method, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock as CommonUnit[])\n    }\n  }\n  if (sourceIsClock) {\n    source = clock\n  }\n  // @ts-expect-error\n  if (!metadata && !name) name = source.shortName\n  let filterType: 'none' | 'unit' | 'fn' = 'none'\n  if (filterRequired || filter) {\n    if (is.unit(filter)) {\n      filterType = 'unit'\n    } else {\n      assert(isFunction(filter), '`filter` should be function or unit')\n      filterType = 'fn'\n    }\n  }\n  if (target) {\n    assertNodeSet(target, method, 'target')\n    assertTarget(method, target)\n  } else {\n    if (\n      filterType === 'none' &&\n      targetMayBeStore &&\n      is.store(source) &&\n      is.store(clock)\n    ) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      // @ts-expect-error\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent({name, derived: true, or: metadata})\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  const clockState = createStateRef()\n  let filterNodes: Cmd[] = []\n  if (filterType === 'unit') {\n    const [filterRef, hasFilter] = syncSourceState(\n      filter as DataCarrier,\n      target,\n      // @ts-expect-error\n      clock,\n      clockState,\n      method,\n    )\n    filterNodes = [...readAndFilter(hasFilter), ...readAndFilter(filterRef)]\n  }\n  const [sourceRef, hasSource] = syncSourceState(\n    // @ts-expect-error\n    source,\n    target,\n    clock,\n    clockState,\n    method,\n  )\n  const jointNode = createLinkNode(\n    // @ts-expect-error\n    clock,\n    target,\n    [\n      applyTemplate('sampleSourceLoader'),\n      mov({from: STACK, target: clockState}),\n      ...readAndFilter(hasSource),\n      read(sourceRef, true, batched),\n      ...filterNodes,\n      read(clockState),\n      filterType === 'fn' && userFnCall((src, _, {a}) => filter(src, a), true),\n      fn && userFnCall(callStackAReg),\n      applyTemplate('sampleSourceUpward', isUpward),\n    ],\n    method,\n    fn,\n  )\n  // @ts-expect-error\n  own(source, [jointNode])\n  Object.assign(jointNode.meta, metadata, {joint: true})\n  return target\n}\n\nconst readAndFilter = (state: StateRef) => [\n  read(state),\n  calc((upd, scope, {a}) => a, true),\n]\n\nconst syncSourceState = (\n  source: DataCarrier,\n  target: DataCarrier | DataCarrier[],\n  clock: DataCarrier | DataCarrier[],\n  clockState: StateRef,\n  method: string,\n) => {\n  const isSourceStore = is.store(source)\n  const sourceRef = isSourceStore ? getStoreState(source) : createStateRef()\n  const hasSource = createStateRef(isSourceStore)\n  if (!isSourceStore) {\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: method},\n      regional: true,\n    })\n  }\n  applyTemplate('sampleSource', hasSource, sourceRef, clockState)\n  return [sourceRef, hasSource] as const\n}\n","import {processArgsToConfig} from './config'\nimport {validateSampleConfig, createSampling} from './sample'\n\nexport function guard(...args: any[]) {\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  validateSampleConfig(config, 'guard')\n  return createSampling(\n    'guard',\n    config.clock,\n    source,\n    config.filter,\n    config.target,\n    null,\n    config.name,\n    metadata,\n    !config.greedy,\n    false,\n    true,\n  )\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {createLinkNode} from './forward'\nimport {deprecate} from './throw'\n\nexport function restore(obj: any, defaultState: any, config?: any) {\n  if (is.store(obj)) {\n    deprecate(false, 'restore($store)')\n    return obj\n  }\n  if (is.event(obj) || is.effect(obj)) {\n    const domain = getParent(obj)\n    const result = createStore(defaultState, {\n      parent: domain,\n      name: obj.shortName,\n      and: config,\n    })\n    createLinkNode(is.effect(obj) ? obj.doneData : obj, result)\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(\n    obj,\n    (value, key) =>\n      (result[key] = is.store(value) ? value : createStore(value, {name: key})),\n  )\n  return result\n}\n","import type {DataCarrier} from './unit.h'\nimport type {Cmd, Stack} from './index.h'\nimport {is, isFunction, isObject, assertTarget} from './is'\nimport {add, forIn, includes} from './collection'\nimport {addRefOp, createStateRef} from './stateRef'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {compute, userFnCall, calc, read} from './step'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {assert} from './throw'\nimport {createEvent} from './createUnit'\nimport {applyTemplate} from './template'\nimport {createSampling} from './sample'\n\nconst launchCase = (\n  scopeTargets: Record<string, DataCarrier>,\n  field: string,\n  data: any,\n  stack: Stack,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]) {\n  const METHOD = 'split'\n  let targets: Record<string, DataCarrier>\n  let clock: void | DataCarrier | DataCarrier[]\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const configForm = !match\n  if (configForm) {\n    targets = source.cases\n    match = source.match\n    clock = source.clock\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  assert(is.unit(source), 'source must be a unit')\n  if (!targets!) targets = {}\n  if (!configForm) {\n    assert(matchIsShape, 'match should be an object')\n    forIn(\n      match,\n      (_, key) =>\n        (targets[key] = createEvent({\n          derived: true,\n          and: metadata,\n        })),\n    )\n    targets.__ = createEvent({derived: true, and: metadata})\n  } else {\n    forIn(targets, (target, field) =>\n      assertTarget(METHOD, target, `cases.${field}`),\n    )\n  }\n  const owners = new Set(\n    ([] as DataCarrier[]).concat(source, clock || [], Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && read(getStoreState(match), false, true),\n      compute({\n        safe: matchIsUnit,\n        filter: true,\n        pure: !matchIsUnit,\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        add(units, key)\n        // @ts-expect-error\n        owners.add(storeOrFn)\n        const updater = createLinkNode(\n          storeOrFn,\n          [],\n          [read(lastValues), calc((upd, _, {a}) => (a[key] = upd))],\n        )\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          addRefOp(lastValues, {from: storeRef, field: key, type: 'field'})\n          applyTemplate('splitMatchStore', storeRef, updater)\n        }\n      }\n    })\n    if (needBarrier!) {\n      applyTemplate('splitBase', lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && read(lastValues, false, true),\n      userFnCall((data, scopeTargets, stack) => {\n        for (let i = 0; i < caseNames.length; i++) {\n          const caseName = caseNames[i]\n          const caseValue = includes(units, caseName)\n            ? stack.a[caseName]\n            : match[caseName](data)\n          if (caseValue) {\n            launchCase(scopeTargets, caseName, data, stack)\n            return\n          }\n        }\n        launchCase(scopeTargets, '__', data, stack)\n      }, true),\n    ]\n  } else {\n    assert(false, 'expect match to be unit, function or object')\n  }\n  const splitterNode = createNode({\n    meta: {op: METHOD},\n    parent: clock ? [] : source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {owners: Array.from(owners)},\n    regional: true,\n  })\n  if (clock) {\n    createSampling(\n      METHOD,\n      clock,\n      source,\n      null,\n      splitterNode,\n      null,\n      METHOD,\n      metadata,\n      /* non-batched */\n      false,\n      false,\n      false,\n    )\n  }\n  if (!configForm) return targets\n}\n","import {add} from '../collection'\nimport {createDefer} from '../defer'\nimport {is} from '../is'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope, Event, Effect, DataCarrier, SettledDefer} from '../unit.h'\n\nexport function allSettled<T>(\n  start: Event<T> | Effect<T, any, any>,\n  {scope, params: ctx}: {scope: Scope; params?: unknown},\n) {\n  if (!is.unit(start))\n    return Promise.reject(new Error('first argument should be unit'))\n  if (!is.effect(start) && !is.event(start) && !is.store(start))\n    return Promise.reject(\n      new Error('first argument accepts only effects, events and stores'),\n    )\n  const defer = createDefer() as SettledDefer\n  defer.parentFork = forkPage\n  const {fxCount} = scope\n  add(fxCount.scope.defers, defer)\n\n  const launchUnits: DataCarrier[] = [start]\n  const launchParams = [] as Array<{params: unknown; req: unknown} | null>\n  add(\n    launchParams,\n    is.effect(start)\n      ? {\n          params: ctx,\n          req: {\n            rs(value: unknown) {\n              defer.value = {status: 'done', value}\n            },\n            rj(value: unknown) {\n              defer.value = {status: 'fail', value}\n            },\n          },\n        }\n      : ctx,\n  )\n  add(launchUnits, fxCount)\n  add(launchParams, null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    scope,\n  })\n  return defer.req\n}\n","import {getMeta, getOwners, getLinks} from '../getter'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport type {Store, Effect, ValuesMap, HandlersMap} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {STORE} from '../tag'\n\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n) {\n  const list = [] as Node[]\n  ;(function visit(node) {\n    if (includes(list, node)) return\n    add(list, node)\n    if (getMeta(node, 'op') === STORE && getMeta(node, 'sid')) {\n      fn(node, getMeta(node, 'sid'))\n    }\n    forEach(node.next, visit)\n    forEach(getOwners(node), visit)\n    forEach(getLinks(node), visit)\n  })(root)\n}\n\ntype StoreOrEffect = Store<any> | Effect<any, any, any>\n\nexport function normalizeValues(\n  values: ValuesMap | HandlersMap,\n  assertEach?: (key: StoreOrEffect, value: any) => void,\n) {\n  const mapOrRecordValues: Map<StoreOrEffect, any> | Record<string, any> =\n    Array.isArray(values) ? new Map(values as [StoreOrEffect, any][]) : values\n  if (mapOrRecordValues instanceof Map) {\n    const result = {} as Record<string, any>\n    forEach(mapOrRecordValues, (value, key) => {\n      assert(\n        (is.unit as (val: unknown) => val is StoreOrEffect)(key),\n        'Map key should be a unit',\n      )\n      if (assertEach) assertEach(key, value)\n      assert(key.sid, 'unit should have a sid')\n      assert(!(key.sid! in result), 'duplicate sid found')\n      result[key.sid!] = value\n    })\n    return result\n  }\n  return mapOrRecordValues\n}\n","import {is} from '../is'\nimport {assert} from '../throw'\nimport type {Domain, ValuesMap, HandlersMap, Scope} from '../unit.h'\nimport {normalizeValues} from './util'\nimport {createScope} from './createScope'\nimport {forEach} from '../collection'\n\ntype ForkConfig = {\n  values?: ValuesMap\n  handlers?: HandlersMap\n  scope?: Scope\n}\n\nexport function fork(\n  domainOrConfig?: Domain | ForkConfig,\n  optiionalConfig?: ForkConfig,\n) {\n  let config: ForkConfig | void = domainOrConfig as any\n  let domain: Domain\n  if (is.domain(domainOrConfig)) {\n    domain = domainOrConfig\n    config = optiionalConfig\n  }\n\n  const scope = createScope(domain!)\n\n  if (config) {\n    const oldScope = config.scope\n    if (oldScope) {\n      const activeEffects = oldScope.activeEffects\n      oldScope.activeEffects = []\n      scope.activeEffects = activeEffects\n      forEach(activeEffects, scopeRef => (scopeRef.ref = scope))\n    }\n    if (config.values) {\n      const valuesSidMap = normalizeValues(config.values, unit =>\n        assert(is.store(unit), 'Values map can contain only stores as keys'),\n      )\n      Object.assign(scope.sidValuesMap, valuesSidMap)\n      scope.fromSerialize =\n        !Array.isArray(config.values) && !(config.values instanceof Map)\n    }\n    if (config.handlers) {\n      scope.handlers = normalizeValues(config.handlers, unit =>\n        assert(\n          is.effect(unit),\n          `Handlers map can contain only effects as keys`,\n        ),\n      )\n    }\n  }\n  return scope\n}\n","import {getForkPage, getGraph, getMeta, getParent} from '../getter'\nimport {setForkPage, getPageRef, currentPage} from '../kernel'\nimport {createNode} from '../createNode'\nimport {calc, compute} from '../step'\nimport type {Domain, Scope, SettledDefer, Store} from '../unit.h'\nimport type {StateRef} from '../index.h'\nimport {forEach} from '../collection'\nimport {DOMAIN, SAMPLER, SCOPE} from '../tag'\n\nexport function createScope(unit?: Domain): Scope {\n  const forkInFlightCounter = createNode({\n    scope: {\n      defers: [],\n      inFlight: 0,\n      fxID: 0,\n    },\n    node: [\n      calc((_, scope, stack) => {\n        if (!getParent(stack)) {\n          scope.fxID += 1\n          return\n        }\n        if (getMeta(getParent(stack).node, 'needFxCounter') === 'dec') {\n          scope.inFlight -= 1\n        } else {\n          scope.inFlight += 1\n          scope.fxID += 1\n        }\n      }),\n      compute({priority: SAMPLER, batch: true}),\n      calc(\n        (\n          _,\n          scope: {\n            inFlight: number\n            fxID: number\n            defers: SettledDefer[]\n          },\n        ) => {\n          const {defers, fxID} = scope\n          if (scope.inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), defer => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n        false,\n        true,\n      ),\n    ],\n  })\n  const page = {} as Record<string, StateRef>\n  const storeChange = createNode({\n    node: [\n      calc((value, __, stack) => {\n        const storeStack = getParent(stack)\n        if (storeStack) {\n          const storeNode = storeStack.node\n          if (\n            !getMeta(storeNode, 'isCombine') ||\n            (getParent(storeStack) &&\n              getMeta(getParent(storeStack).node, 'op') !== 'combine')\n          ) {\n            const forkPage = getForkPage(stack)!\n            const id = storeNode.scope.state.id\n            const sid = getMeta(storeNode, 'sid')\n            forkPage.sidIdMap[sid] = id\n            forkPage.sidValuesMap[sid] = value\n\n            const serialize = getMeta(storeNode, 'serialize')\n            if (serialize && serialize !== 'ignore') {\n              forkPage.sidSerializeMap[sid] = serialize.write\n            }\n          }\n        }\n      }),\n    ],\n  })\n  const warnSerializeNode = createNode({\n    node: [\n      calc((_, __, stack) => {\n        const forkPage = getForkPage(stack)\n        if (forkPage) {\n          const storeStack = getParent(stack)\n          if (storeStack) {\n            const storeNode = storeStack.node\n            if (\n              !getMeta(storeNode, 'isCombine') ||\n              (getParent(storeStack) &&\n                getMeta(getParent(storeStack).node, 'op') !== 'combine')\n            ) {\n              forkPage.warnSerialize = true\n            }\n          }\n        }\n      }),\n    ],\n  })\n  const resultScope: Scope = {\n    cloneOf: unit,\n    reg: page,\n    sidValuesMap: {},\n    sidIdMap: {},\n    sidSerializeMap: {},\n    getState(store: StateRef | Store<any>) {\n      if ('current' in store) {\n        return getPageRef(currentPage, resultScope, null, store).current\n      }\n      const node = getGraph(store)\n      return getPageRef(currentPage, resultScope, node, node.scope.state, true)\n        .current\n    },\n    kind: SCOPE,\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, storeChange, warnSerializeNode],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n    additionalLinks: {},\n    handlers: {},\n    fxCount: forkInFlightCounter,\n    storeChange,\n    warnSerializeNode,\n    activeEffects: [],\n  }\n  return resultScope\n}\n","import {is, isObject} from '../is'\nimport {assert} from '../throw'\nimport {launch} from '../kernel'\nimport type {Domain, Scope, ValuesMap} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, includes} from '../collection'\nimport {normalizeValues, traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain | Scope, {values}: {values: ValuesMap}) {\n  assert(isObject(values), 'values property should be an object')\n  const normalizedValues = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(normalizedValues)\n  const storeNodes: Node[] = []\n  const storeValues: any[] = []\n  let forkPage: Scope\n  let traverseTarget: Node\n  let needToAssign: true | void\n  if (is.scope(domain)) {\n    forkPage = domain\n    needToAssign = true\n    assert(forkPage.cloneOf, 'scope should be created from domain')\n    traverseTarget = getGraph(forkPage.cloneOf)\n  } else if (is.domain(domain)) {\n    traverseTarget = getGraph(domain)\n  } else {\n    assert(false, 'first argument of hydrate should be domain or scope')\n  }\n  traverseStores(traverseTarget!, (node, sid) => {\n    // forkPage.sidIdMap[sid] = node.scope.state.id\n    if (includes(valuesSidList, sid)) {\n      add(storeNodes, node)\n      const serializer = getMeta(node, 'serialize')\n      if (serializer && serializer !== 'ignore') {\n        normalizedValues[sid] = serializer.read(normalizedValues[sid])\n      }\n      add(storeValues, normalizedValues[sid])\n    }\n  })\n  launch({\n    target: storeNodes,\n    params: storeValues,\n    scope: forkPage!,\n  })\n  if (needToAssign) {\n    Object.assign(forkPage!.sidValuesMap, normalizedValues)\n  }\n}\n","import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\nimport type {Unit} from '../index.h'\n\n/** bind event to scope */\nexport function scopeBind(\n  unit: Unit,\n  {scope, safe}: {scope?: Scope; safe?: true} = {},\n) {\n  assert(\n    scope || forkPage || safe,\n    'scopeBind cannot be called outside of forked .watch',\n  )\n  const savedForkPage = scope || forkPage!\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: unit,\n          params: {\n            params,\n            req,\n          },\n          scope: savedForkPage,\n        })\n        return req.req\n      }\n    : (params: any) => {\n        launch({target: unit, params, scope: savedForkPage})\n        return params\n      }\n}\n","import type {Scope, Store} from '../unit.h'\nimport {forIn, includes} from '../collection'\nimport {assert} from '../throw'\nimport {traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\nconst noopSerializer = (x: any) => x\n/**\n serialize state on server\n */\nexport function serialize(\n  scope: Scope,\n  config: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  if (scope.warnSerialize) {\n    console.error(\n      'There is a store without sid in this scope, its value is omitted',\n    )\n  }\n  const ignoredStores = config.ignore ? config.ignore.map(({sid}) => sid) : []\n  const result = {} as Record<string, any>\n  forIn(scope.sidValuesMap, (value, sid) => {\n    if (includes(ignoredStores, sid)) return\n    const id = scope.sidIdMap[sid]\n    const serializer = scope.sidSerializeMap[sid] || noopSerializer\n    // if (!scope.changedStores.has(id)) return\n    if (id && id in scope.reg) {\n      result[sid] = serializer(scope.reg[id].current)\n    } else {\n      result[sid] = serializer(value)\n    }\n  })\n  if ('onlyChanges' in config && !config.onlyChanges) {\n    assert(scope.cloneOf, 'scope should be created from domain')\n    traverseStores(getGraph(scope.cloneOf), (node, sid) => {\n      if (\n        !(sid in result) &&\n        !includes(ignoredStores, sid) &&\n        !getMeta(node, 'isCombine') &&\n        getMeta(node, 'serialize') !== 'ignore'\n      )\n        result[sid] = scope.getState(node as any)\n    })\n  }\n  return result\n}\n","import {clearNode} from './clearNode'\nimport {createNode} from './createNode'\nimport type {Node, Subscription, Unit} from './index.h'\nimport {step} from './step'\nimport {Scope} from './unit.h'\n\nexport function createWatch<T>({\n  unit,\n  fn,\n  scope,\n}: {\n  unit: Unit<T>\n  fn: (value: T) => any\n  scope?: Scope\n}): Subscription {\n  const seq = [step.run({fn: value => fn(value)})]\n  if (scope) {\n    const node = createNode({node: seq})\n    const id = (unit as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return createSubscription(() => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    })\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [unit],\n      family: {owners: unit},\n    })\n    return createSubscription(() => {\n      clearNode(node)\n    })\n  }\n}\n\nfunction createSubscription(callback: () => void): Subscription {\n  const subscription: Subscription = () => callback()\n  subscription.unsubscribe = () => callback()\n\n  return subscription\n}\n","export const observableSymbol =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import type {Node, StateRef, NodeUnit} from './index.h'\nimport type {Scope, Store, CommonUnit, Domain} from './unit.h'\n\nexport const getGraph = (graph: NodeUnit): Node =>\n  (graph as {graphite: Node}).graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: Store<any>): StateRef => store.stateRef\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: Store<any>) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any): Scope | void => val.scope\nexport const getMeta = (unit: NodeUnit, field: string) =>\n  getGraph(unit).meta[field]\nexport const setMeta = (unit: NodeUnit, field: string, value: unknown) =>\n  (getGraph(unit).meta[field] = value)\nexport const getCompositeName = (unit: CommonUnit | Domain) =>\n  unit.compositeName\n","import type {Kind, Unit} from './index.h'\nimport type {Domain, Effect, Event, Scope, Store} from './unit.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {getMeta} from './getter'\n\nexport const unit = (obj: unknown): obj is Unit<any> =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: Kind) => (obj: unknown) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value: unknown) => value is Store<unknown>\nexport const event = is(EVENT) as (value: unknown) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value: unknown,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value: unknown) => value is Domain\nexport const scope = is(SCOPE) as (value: unknown) => value is Scope\nexport const attached = (unit: unknown) =>\n  effect(unit) && getMeta(unit, 'attached') === true\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n","import type {Stack} from './index.h'\n\nexport const callStackAReg = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(stack, a)\nexport const callARegStack = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: {[key: string]: any}, _: Stack) =>\n  fn(stack)\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n  Stack,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag} from './kernel'\nimport {callStack} from './caller'\n\nconst cmd = <Type extends 'compute' | 'mov'>(\n  type: Type,\n  data: any,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result: {\n    id: string\n    type: Type\n    data: any\n    order?: {\n      priority: BarrierPriorityTag\n      barrierID?: number\n    }\n  } = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n  pure = false,\n}: {\n  fn?: (data: any, scope: LocalValues, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n  pure?: boolean\n}): Compute => cmd('compute', {fn, safe, filter, pure}, priority, batch)\n\nexport const filter = ({\n  fn,\n  pure,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n  pure?: boolean\n}) => compute({fn, filter: true, pure})\n\nexport const run = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, priority: EFFECT})\n\nexport const calc = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>(\n  fn: (data: any, scope: LocalValues, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const userFnCall = (\n  fn: (data: any, scope: {[key: string]: any}, stack: Stack) => any = callStack,\n  isFilter?: boolean,\n) => compute({fn, pure: true, filter: isFilter})\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-expect-error\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && getMeta(targetNode, 'op') !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: Map<any, any> | Set<any>) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-expect-error\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet, assertTarget} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const method = 'forward'\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  assertNodeSet(from, method, '\"from\"')\n  assertNodeSet(to, method, '\"to\"')\n  assertTarget(method, to, 'to')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: method, config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}